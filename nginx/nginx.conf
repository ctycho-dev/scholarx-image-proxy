# Nginx configuration for ScholarX Image Proxy
# Purpose: Proxy Cloudflare R2 images for Russian users to bypass 16KB throttling
# Server: Amsterdam VPS

# ============================================================================
# CACHE CONFIGURATION
# ============================================================================

# Define cache storage
# - 100MB shared memory zone = ~800,000 cached URLs
# - 10GB max disk space
# - 365 days retention for unused files
# - Two-level directory hierarchy (levels=1:2) for performance
proxy_cache_path /var/cache/nginx/r2_images 
                 levels=1:2 
                 keys_zone=r2_cache:100m 
                 max_size=10g 
                 inactive=365d 
                 use_temp_path=off;

# ============================================================================
# UPSTREAM (FASTAPI BACKEND)
# ============================================================================

upstream fastapi_backend {
    # FastAPI running locally on port 8000
    server fastapi:8000;
    
    # Keep 32 idle connections open for connection reuse
    keepalive 32;
    
    # Retry configuration
    # max_fails 3;
    # fail_timeout 30s;
}

# ============================================================================
# MAIN SERVER BLOCK
# ============================================================================

server {
    listen 80;
    listen [::]:80;
    
    # Accept all hostnames (override with your domain later)
    server_name _;
    
    # Server tokens off for security
    server_tokens off;
    
    # Logging
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log warn;
    
    # ========================================================================
    # CLIENT SETTINGS
    # ========================================================================
    
    # Max file size (images are typically <5MB)
    client_max_body_size 50M;
    
    # Timeouts for slow Russian connections
    client_body_timeout 60s;
    client_header_timeout 60s;
    
    # ========================================================================
    # MAIN PROXY LOCATION (All image requests)
    # ========================================================================
    
    location / {
        # --------------------------------------------------------------------
        # CACHE CONFIGURATION
        # --------------------------------------------------------------------
        
        # Use the cache zone defined above
        proxy_cache r2_cache;
        
        # Cache successful responses for 1 year
        proxy_cache_valid 200 365d;
        
        # Cache 404s briefly (1 minute) - don't hammer backend for missing files
        proxy_cache_valid 404 1m;
        
        # Cache key: Makes each unique URL a separate cache entry
        # Example: httpGETproxy.yoursite.com/home/main/circle.png
        proxy_cache_key "$scheme$request_method$host$request_uri";
        
        # Cache locking: Prevents thundering herd
        # If 100 users request same uncached image, only 1 hits backend
        proxy_cache_lock on;
        proxy_cache_lock_timeout 10s;
        
        # Background updates: Serve stale content while revalidating
        proxy_cache_background_update on;
        
        # Use stale cache if backend is down/slow/updating
        proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
        
        # Revalidate stale content in background
        proxy_cache_revalidate on;
        
        # Ignore backend cache control headers (we control caching)
        proxy_ignore_headers Cache-Control Expires;
        
        # --------------------------------------------------------------------
        # HEADERS (Debug & Client)
        # --------------------------------------------------------------------
        
        # Add cache status header for debugging
        # Values: HIT, MISS, EXPIRED, STALE, UPDATING, REVALIDATED, BYPASS
        add_header X-Cache-Status $upstream_cache_status always;
        
        # Tell browsers to cache for 1 year
        add_header Cache-Control "public, max-age=31536000, immutable" always;
        
        # CORS headers (if needed for cross-origin requests)
        add_header Access-Control-Allow-Origin "*" always;
        add_header Access-Control-Allow-Methods "GET, HEAD, OPTIONS" always;
        
        # Security headers
        add_header X-Content-Type-Options "nosniff" always;
        
        # --------------------------------------------------------------------
        # PROXY SETTINGS
        # --------------------------------------------------------------------
        
        # Forward to FastAPI backend
        proxy_pass http://fastapi_backend;
        
        # HTTP/1.1 required for keepalive
        proxy_http_version 1.1;
        
        # Clear "Connection: close" to enable keepalive
        proxy_set_header Connection "";
        
        # Forward original request headers
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # --------------------------------------------------------------------
        # BUFFERING (For large image files)
        # --------------------------------------------------------------------
        
        # Enable buffering for better performance
        proxy_buffering on;
        
        # Buffer settings for images
        proxy_buffer_size 4k;
        proxy_buffers 8 4k;
        proxy_busy_buffers_size 8k;
        proxy_max_temp_file_size 1024m;
        
        # --------------------------------------------------------------------
        # TIMEOUTS
        # --------------------------------------------------------------------
        
        # Connection timeout to FastAPI
        proxy_connect_timeout 10s;
        
        # Timeout sending request to FastAPI
        proxy_send_timeout 60s;
        
        # Timeout reading response from FastAPI
        proxy_read_timeout 60s;
    }
    
    # ========================================================================
    # HEALTH CHECK ENDPOINT (No caching)
    # ========================================================================
    
    location /health {
        # Direct pass to FastAPI, no caching
        proxy_pass http://fastapi_backend/health;
        proxy_cache off;
        
        # Don't log health checks (reduces log spam)
        access_log off;
        
        # Quick timeout for health checks
        proxy_connect_timeout 2s;
        proxy_read_timeout 2s;
    }
    
    # ========================================================================
    # NGINX STATUS PAGE (For Docker healthcheck)
    # ========================================================================
    
    location /nginx_status {
        # Only allow from localhost (Docker internal)
        allow 127.0.0.1;
        deny all;
        
        stub_status;
        access_log off;
    }
}

# ============================================================================
# OPTIONAL: SSL/TLS CONFIGURATION (Recommended for production)
# ============================================================================
# Uncomment and configure if you have SSL certificate

# server {
#     listen 443 ssl http2;
#     listen [::]:443 ssl http2;
#     
#     server_name proxy.yoursite.com;
#     
#     # SSL certificate paths (use Let's Encrypt certbot)
#     ssl_certificate /etc/letsencrypt/live/proxy.yoursite.com/fullchain.pem;
#     ssl_certificate_key /etc/letsencrypt/live/proxy.yoursite.com/privkey.pem;
#     
#     # SSL configuration
#     ssl_protocols TLSv1.2 TLSv1.3;
#     ssl_ciphers HIGH:!aNULL:!MD5;
#     ssl_prefer_server_ciphers on;
#     ssl_session_cache shared:SSL:10m;
#     ssl_session_timeout 10m;
#     
#     # Include all location blocks from above
#     # (copy the location blocks here)
# }

# # Redirect HTTP to HTTPS
# server {
#     listen 80;
#     listen [::]:80;
#     server_name proxy.yoursite.com;
#     return 301 https://$server_name$request_uri;
# }
